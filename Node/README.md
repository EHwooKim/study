## JS 이벤트 루프

* 함수들을 `호출 스택`에 넣고 들어간 `반대순서로`실행을 시킨다. `setTimeout`과 같은 함수가 이ㄸ마녀 `백그라운드`로 콜백함수를 넣고 해당 시간이 다 지나고 나면 콜백함수를 `태스크 큐`로 보낸다.  이벤트 루프는 `호출 스택`이 비어있다면 `태스큐 큐`에서 함수를 하나씩 가져와 `호출 스택`에 넣고 실행한다.
* **호출 스택이 비어있다면!!!! 태스큐 큐에서 함수를 가져오기 때문에**  정해진 시간 후에 바로 콜백 함수가 실행이 안될 수도 있다. 이러한 이유 때문에 `setTimeout`의 시간이 정확하게 작동하지 않을 때가 있다.

##  프로세스 vs 스레드

> 노드는 싱글 스레드, 논블로킹 모델이다.

* 식당을 예로 들면 한명의 점원이 여러 손님의 주문을 모두 받고 요리가 완료되는 순서대로 서빙한다. (주문순서, 서빙순서가 일치 X)

> 노드는 싱글 스레드 여러 개를 사용해 멀티 스레딩과 비슷한 기능을 할 수 있다.
>
> 엄밀히 말하면 멀티 스레딩이라기보단 멀리 프로세싱에 가깝다.

| 프로세스                                                     | 스레드                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 운영체제에서 할당하는 작업의 단위.<br />노드, 인터넷 브라우저 같은 프로그램이 개별적인 프로세스이다<br />프로세스 간에는 메모리 등의 자원을 공유하지 않는다. | 프로세스 내에서 시행되는 흐름의 단위<br />하나의 프로세슨 느스레드를 여러개 가질 수 있다<br />스레드들은 부모 프로세스의 자원을 공유한다<br />즉, 같은 메모리에 접근할 수 있다. |

* 스레드를 작업을 처리하는 일손으로 표현하기도 하는데, 노드 프로세스는 일손이 하나인 셈이다.
* 내부적으로는 스레드를 여러 개 가지고 있으나 직접 제어 가능한 스레드는 하나뿐이므로 `싱글스레드`라고 부른다

## 서버로서의 노드

> 노드 서버 역시 싱글 스레드, 논블로킹 방식이며 그에 따른 장단점이 있다.

* 싱글 스레드이기 때문에 컴퓨터 자원은 적게 사용하는 `장점`이 있지만, CPU 코어를 하나밖에 사용하지 못하는 `단점`이 있다

* 노드 서버는  `I/O`가 많은 작업에 적합하다.

  >libuv 라이브러리를 이용한 논블로킹 I/O

## 노드의 장/단점

| 장점                                               | 단점                                          |
| -------------------------------------------------- | --------------------------------------------- |
| 멀티 스레드 방식에 비해 컴퓨터 자원을 적게 사용함. | 싱글 스레드라서 CPU 코어를 하나만 사용함      |
| I/O 작업이 많은 서버로 적합                        | CPU 작업이 많은 서버로는 부적합               |
| 멀티 스레드 방식보다 쉬움.                         | 하나뿐인 스레드가 멈추지 않도록 관리를 해야함 |
| 웹 서버가 내장되어 있음                            | 서버 규모가 커졌을 떄 서버를 관리하기 어려움  |
| 자바스크립트를 사용함                              | 어중간한 성능                                 |
| JSON 형식과 호환하기 쉬움.                         |                                               |

> 결국 개수는 많지만 크기가 작은 데이터를 실시간으로 주고 받는 데 적합하다! (채팅, 주식차트 등...)
>
> (이미지 비디오처리, 대구모 데이터 처리에는 부적합)

## ES2015

### const, let

> 함수 스코프가 아닌 블록스코프, const는 재선언, 재할당 불가능

### 템플릿 문자열

> 백틱(`)을 활용한 변수 넣기

### 객체 리터럴

``` javascript
{name: name, age: age} //ES5
{name, age} //ES2015
```

> 속성명과 변수명이 겹치는 경우 한 번만 써도 된다..
>
> 객체의 속성명을 동적으로 생성이 가능하다 등..

### 화살표 함수

> this 사용에 유의

### 비구조화 할당

> 객체와 배열로부터 속성이나 요소를 쉽게 꺼낼 수 있다.

#### 객체

``` javascript
const candyMachine = {
    status: {
        name: 'node',
        count: 5
    },
    getCandy() {
        this.status.count--
        return this.status.count
    }
}
const { getCandy, status: { count } } = candyMachine
```

> candyMachine 객체 안의 속성을 찾아서 변수와 매칭해준다.

#### 배열

```javascript
const array = ['nodejs', {}, 10, true]
const [node, obj, , bool = array
```

> array의 첫번쨰, 두번쨰, 마지막 요소를 할당.
>
> obj 와 bool 사이의 요소들은 무시한다.

### 프로미스

> 콜백지옥을 해결해준 감사한 친구

*  `new Promise`로   `resolve`와 `reject` 를 매개변수로 하는 프로미스 객체를 만들어 사용하며, 만들어진 promise 변수에 `then`과 `catch` 메서드를 붙일 수 있다. 
  * `resolve` -> `then`
  * `reject` -> `catch`
* resolve, reject에 넣은 인자는 각각 then, catch 의 매개변수에서 받을 수 있다.

## 노드 내장 객체

#### global

> 남용금지..

#### console

> console 객체는 보통 디버깅을 위해 사용된다.

* `time(레이블) / timeEnd(레이블)`

  ```javascript
  console.time('시간측정')
  ...
  console.timeEnd('시간측정')
  ```

  > `time`과 `timeEnd`사이의 시간을 측정한다.

* `console.dir(객체, 옵션)`

  ```javascript
  console.idr(obj, { colors:true, depth:1 })
  ```

  > 객체를 콘솔에 표시할 떄 사용.
  >
  > 첫번째 인자로 표시할 객체, 두번째 인자로 옵션을 넣는다. (기본 depth: 2)



