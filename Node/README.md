## JS 이벤트 루프

* 함수들을 `호출 스택`에 넣고 들어간 `반대순서로`실행을 시킨다. `setTimeout`과 같은 함수가 이ㄸ마녀 `백그라운드`로 콜백함수를 넣고 해당 시간이 다 지나고 나면 콜백함수를 `태스크 큐`로 보낸다.  이벤트 루프는 `호출 스택`이 비어있다면 `태스큐 큐`에서 함수를 하나씩 가져와 `호출 스택`에 넣고 실행한다.
* **호출 스택이 비어있다면!!!! 태스큐 큐에서 함수를 가져오기 때문에**  정해진 시간 후에 바로 콜백 함수가 실행이 안될 수도 있다. 이러한 이유 때문에 `setTimeout`의 시간이 정확하게 작동하지 않을 때가 있다.

##  프로세스 vs 스레드

> 노드는 싱글 스레드, 논블로킹 모델이다.

* 식당을 예로 들면 한명의 점원이 여러 손님의 주문을 모두 받고 요리가 완료되는 순서대로 서빙한다. (주문순서, 서빙순서가 일치 X)

> 노드는 싱글 스레드 여러 개를 사용해 멀티 스레딩과 비슷한 기능을 할 수 있다.
>
> 엄밀히 말하면 멀티 스레딩이라기보단 멀리 프로세싱에 가깝다.

| 프로세스                                                     | 스레드                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 운영체제에서 할당하는 작업의 단위.<br />노드, 인터넷 브라우저 같은 프로그램이 개별적인 프로세스이다<br />프로세스 간에는 메모리 등의 자원을 공유하지 않는다. | 프로세스 내에서 시행되는 흐름의 단위<br />하나의 프로세슨 느스레드를 여러개 가질 수 있다<br />스레드들은 부모 프로세스의 자원을 공유한다<br />즉, 같은 메모리에 접근할 수 있다. |

* 스레드를 작업을 처리하는 일손으로 표현하기도 하는데, 노드 프로세스는 일손이 하나인 셈이다.
* 내부적으로는 스레드를 여러 개 가지고 있으나 직접 제어 가능한 스레드는 하나뿐이므로 `싱글스레드`라고 부른다

## 서버로서의 노드

> 노드 서버 역시 싱글 스레드, 논블로킹 방식이며 그에 따른 장단점이 있다.

* 싱글 스레드이기 때문에 컴퓨터 자원은 적게 사용하는 `장점`이 있지만, CPU 코어를 하나밖에 사용하지 못하는 `단점`이 있다

* 노드 서버는  `I/O`가 많은 작업에 적합하다.

  >libuv 라이브러리를 이용한 논블로킹 I/O

## 노드의 장/단점

| 장점                                               | 단점                                          |
| -------------------------------------------------- | --------------------------------------------- |
| 멀티 스레드 방식에 비해 컴퓨터 자원을 적게 사용함. | 싱글 스레드라서 CPU 코어를 하나만 사용함      |
| I/O 작업이 많은 서버로 적합                        | CPU 작업이 많은 서버로는 부적합               |
| 멀티 스레드 방식보다 쉬움.                         | 하나뿐인 스레드가 멈추지 않도록 관리를 해야함 |
| 웹 서버가 내장되어 있음                            | 서버 규모가 커졌을 떄 서버를 관리하기 어려움  |
| 자바스크립트를 사용함                              | 어중간한 성능                                 |
| JSON 형식과 호환하기 쉬움.                         |                                               |

> 결국 개수는 많지만 크기가 작은 데이터를 실시간으로 주고 받는 데 적합하다! (채팅, 주식차트 등...)
>
> (이미지 비디오처리, 대구모 데이터 처리에는 부적합)

## ES2015

### const, let

> 함수 스코프가 아닌 블록스코프, const는 재선언, 재할당 불가능

### 템플릿 문자열

> 백틱(`)을 활용한 변수 넣기

### 객체 리터럴

``` javascript
{name: name, age: age} //ES5
{name, age} //ES2015
```

> 속성명과 변수명이 겹치는 경우 한 번만 써도 된다..
>
> 객체의 속성명을 동적으로 생성이 가능하다 등..

### 화살표 함수

> this 사용에 유의

### 비구조화 할당

> 객체와 배열로부터 속성이나 요소를 쉽게 꺼낼 수 있다.

#### 객체

``` javascript
const candyMachine = {
    status: {
        name: 'node',
        count: 5
    },
    getCandy() {
        this.status.count--
        return this.status.count
    }
}
const { getCandy, status: { count } } = candyMachine
```

> candyMachine 객체 안의 속성을 찾아서 변수와 매칭해준다.

#### 배열

```javascript
const array = ['nodejs', {}, 10, true]
const [node, obj, , bool = array
```

> array의 첫번쨰, 두번쨰, 마지막 요소를 할당.
>
> obj 와 bool 사이의 요소들은 무시한다.

### 프로미스

> 콜백지옥을 해결해준 감사한 친구

*  `new Promise`로   `resolve`와 `reject` 를 매개변수로 하는 프로미스 객체를 만들어 사용하며, 만들어진 promise 변수에 `then`과 `catch` 메서드를 붙일 수 있다. 
  * `resolve` -> `then`
  * `reject` -> `catch`
* resolve, reject에 넣은 인자는 각각 then, catch 의 매개변수에서 받을 수 있다.

## 노드 내장 객체

### global

> 남용금지..

### console

> console 객체는 보통 디버깅을 위해 사용된다.

* `time(레이블) / timeEnd(레이블)`

  ```javascript
  console.time('시간측정')
  ...
  console.timeEnd('시간측정')
  ```

  > `time`과 `timeEnd`사이의 시간을 측정한다.

* `console.dir(객체, 옵션)`

  ```javascript
  console.idr(obj, { colors:true, depth:1 })
  ```

  > 객체를 콘솔에 표시할 떄 사용.
  >
  > 첫번째 인자로 표시할 객체, 두번째 인자로 옵션을 넣는다. (기본 depth: 2)

### 타이머 

* `setTimeout(콜백 함수, 밀리초)` & `clearTimeout(아이디)` : 주어진 밀리초 이후 콜백 실행

* `setInterval(콜백 함수, 밀리초)` & `clearInterval(아이디)`: 주어진 밀리초마다 콜백 반복

* `setImmediate(콜백 함수)` & `clearImmediate(아이디)`: 즉시 실행

  > 타이머 함수들은 모두 아이디를 반환한다.  아이디를 사용하여( 반환되는 아이디를 변수에 담아서 ) 타이머를 취소할 수 있다

* `setImmediate`가  있으니 `setTimeout(콜백, 0)`은 사용하지 않는 것을 권장한다.

### filename, dirname

```javascript
console.log(__filename)
console.log(__dirname)
```

* `path 모듈`과 함께 경로 처리를 할 때 사용한다.

### 마이크로 태스크

```javascript
// nextTick.js
setImmediate(() => {
    console.log('immediate')
})
process.nextTick(() => {
    console.log('nextTick')
})
setTimeout(() => {
    console.log('timeout')
}, 0)
Promise.resolve().then(() => console.log('promise'))
```

```bash
$ node nextTick
nextTick
promise
timeout
immediate
```

* `process.nextTick(콜백)`: 이벤트 루프가 다른 콜백 함수들 보다 nextTick의 콜백 함수를 우선 처리하도록 한다.
* resolve된 promise 역시 다른 콜백들보다 우선시된다.
* 그래서 위의 두개를 마이크로태스크(microtack)라고 따로 구분지어 부른다.

## 노드 내장 모듈

### os

> os 모듈은 컴퓨터 ㅐ부 자원에 빈번하게 접근하는 경우 사용된다.
>
> 일반적인 웹 서비스를 제작할 떄는 사용빈도가 낮지만 운영체제별로 다른 서비스를 제공하고 싶을 때 유용한 모듈이다.

* `os.cpus() `: 컴퓨터의 코어 정보를 보여줍니다.
* `os.cpus().length`: 코어의 개수를 보여준다.
  * 노드는 싱글 스레드라 대부분 하나의 코어만 사용하지만 나중에 `cluster` 모듈을 사용하는 경우 코어의 개수에 맞춰 프로세스를 늘릴 수 있고 이때 `cpus()` 메서드를 사용한다.

### path

> 노드 프로그래밍을 하면서 매우 자주 쓰게 될 모듈

* `path.sep`: 경로 구분자
  * `WIndows: \`
  * `POSIX: /`
  * WIndows에서 POSIX스타일 path를 사용하거나 그 반대의 경우가 있다
    * Windows에서는 `path.posix.sep` , `path.posix.joinn()`  을 사용
    * POSIX에서는 `path.win32.sep`, `path.win32.join()`  을 사용
* `path.delimiter`: 환경 변수 구분자
  * `Windows: ;`
  * `POSIX: :`
* `path.dirname(경로)`: 파일이 위치한 폴더 경로
* `path.extname(경로)`: 파일의 확장자
* `path.basename(경로, 확장자)`: 파일의 이름(확장자 포함)을 보여준다. 파일 이름만 표시하고싶다면 두번째 인자로 확장자를 넣어주면 된다.
* `path.parse(경로)`: 파일 경로를 `root`, `dir`, `base`, `ext`, `name`으로 분리
* `path.format(객체)`: path.parse()한 객체를 파일 경로로 합친다.
* `path.normalize(경로)`: / 나 \ 를 실수로 여러번이나 혼용했을 때 정상적으로 변환
* `path.isAbsolute(경로)`: `true `- 절대경로, `false` - 상대경로
* `path.relative(기준경로, 비교경로)`: 첫번째 경로에서 두번쨰 경로로 가는 방법을 알려준다.

* `path.join(경로, ...)`: 여러 인자를 넣으면 하나의 경로로 합쳐준다.
* `path.resolve(경로, ...)`: path.join과 비슷하지만 약간의 차이가 존재
  * `path.resolve`는 `/`를 만나면 절대 경로로 인식해 앞의 경로를 무시한다.

### url

### crypto

> 암호화를 도와주는 모듈.

#### 단방향

* 암호화는 보통 단방향 암호화 알고르짐을 사용해 암호화한다. (복화할 수 없는 암호화 방식)

  * 단방향 암호화 알고리즘은 보통 해시 기법을 사용한다.

    > 해시기법 - 어떤 문자열을 고정된 길이의 다른 문자열로 바꿔버리는 방식

    ```javascript
    //hash.js
    const crypto = require('crypto')
    
    console.log('base64:', crypto.createHash('sha512').update('비밀번호').digest('base64'))
    ```

    * createHash(알고리즘) : 사용할 해시 알고리즘을 넣는다. `md5`, `sha1`, `sha256`, `sha512`등이 있는데 현재는 `sha512`정도로 충분

    * update(문자열) : 변환할 문자열

    * digest(인코딩) : 인코딩할 알고리즘을 넣는다. `base64`, `hex`, `latin1`등이 있는데 `base64`가 결과 문자열이 가장 짧아 애용된다.

    * update(문자열) : 변환할 문자열

      digest(인코딩) : 인코딩할 알고리즘을 넣는다. base64, hex, latin1등이 있는데 base64가 결과 문자열이 가장 짧아 애용된다.

    * 현재는 주로 `pbkdf2`나 `bcypt`, `scypt` 알고리즘으로 암호화를 한다.

#### 양방향

* 키를 사용한 양방향 암호화 방식 또한 지원한다.

자세한 암호화 방법들은 [공식문서](https://nodejs.org/api/crypto.html) 참고

### util

* `util.deprecate` : 함수가 deprecated 되었음을 알려준다.
* `util.promisify`: 콜백 패턴을 프로미스 패턴으로 바꿔준다.

## 파일 시스템 접근

> fs 모듈을 통해 파일을 생성, 삭제, 읽고 쓰는게 가능하다.

### 읽기, 쓰기

* `fs.readFile(경로, 콜백)` : 파일을 읽습니다. readFIle의 결과물은 `버퍼`라는 형식으로 제공되기에 `data.toString()`을 통해 문자열로 변환해야 한다.

* `fs.writeFile(경로, 내용, 콜백)`

### 동기 메서드, 비동기 메서드

> 다른 fs 모듈을 설명기 전에 필요한 개념들
>
> setTImeout, process.nextTick 외에도 노드는 대부분의 메서드를 비동기 방식으로 처리한다.
>
> 하지만 동기 방식으로 사용할 수 있는 메서드가 있는데 특히 fs 모듈이 그런게 많다.

* `readFile`을 여러번 사용하여 파일을 읽으면 출력 순서가 뒤죽박죽이다.. `비동기`방식이라 그렇다.
* `readFIleSync`를 사용하면 내가 원하는 순서대로 출력은 되나 `동기`방식이라 메인 스레드가 노는 시간이 생겨 비효율적이다. `동기` 메서드 들은  뒤에 `Sync`가 붙어 구분이 쉽다. 하지만 거의 쓰이지 않는다.
* 콜백지옥 혹은 promise, async/await를 이용하면 순서가 바뀌지 않게 비동기 메서드 사용이 가능하다.

### 버퍼와 스트림

> 파일을 읽거나 쓰는 방식에는 크게 두 가지 방식이 있다. 버퍼와 스트림

* 인터넷으로 영상 시청시 많이 들어본 `버퍼링`과 `스트리밍`

  * `버퍼링`은 영상을 재생할 수 있을 떄까지 데이터를 `모으는` 동작이고
  * `스트리밍`은 방송인의 컴퓨터에서 시청자의 컴퓨터로 영상 데이터를 조금씩 `전송`하는 동작이다.

* 노드의 `버퍼`, `스트림`도 비슷한 개념이다.

  * 노드는 파일을 읽을 떄 메러리에 파일 크기만큼 공간을 마련해둠, 파일 데이터를 메모리에 저장한 뒤 사용자가 조작할 수 있도록 해준다.

  * 메모리에 저장된 데이터가 바로 `버퍼`이다.

    > 이 버퍼를 직접 다룰 수 있는 클랙스가 바로 Buffer

#### 버퍼

* `Buffer`
  * `.from(문자열)` : 문자열을 버퍼로 바꿉니다.
  * `.toString()` : 버퍼를 다시 문자열로 바꿉니다.
  * `.concat(배열)`: 배열 안에 든 버퍼들을 하나로 합칩니다.
  * `.alloc(바이트)` : 빈 버퍼를 생성합니다. 바이트를 인자로 지정해주면 해당 크기의 버퍼가 생성됩니다.
* `readfile` 방식의 버퍼가 편리하지만 **문제점**이 있다. 만약 용량이 100MB인 파일있으면 읽을 때 메모리에 100MB의 버퍼를 만들어야 한다. 만약 이 작업을 동시에 열개만 해도 1GB에 달하는 메모리가 사용된다.
* 또한 모든 내용을 버퍼에 다 쓴 후에야 다음 동작으로 넘어가기에 파일 읽기, 압축, 파일 쓰기 등의 조작을 연달아 할 때 매번 전체 용량을 버퍼로 처리해야 다음 단계로 넘어갈 수 있다..
* **그래서!!** 버퍼의 크기를 작게 만들어서 여러번에 나눠 보내는 방식이 등장했는데 그게 바로 `스트림`

#### 스트림

* `createReadStream`, `createWriteStream`
  * 이벤트 리스너를 붙여서 사용한다.
* `createReadStream`으로 파일을 읽고 그 스트림을 전달받아 `createWriteStream`으로 파일을 쓸 수도 있다.
* 이렇게 스트림끼리 연결하는 것을 `파이핑한다`고 표현하고 `pipe`메서드를 사용하면 된다.
* 노드8.5 버전 전까지는 이 `스트림`과 `pipe`를 이용해 파일을 복사하곤 했다. (새로운 복사 방법은 아래에)

### 기타 fs 메서드

* `fs.access(경로, 옵션, 콝백)` : 폴더, 파일에 접근할 수 있는지 체크
* `fs.mkdir(경로, 콜백)` : 폴더를 만드는 메서드 ( 이미 있으면 에러 )
* `fs.open(경로, 옵션, 콜백)` : 파일의 아이디를 가져온다.  ( 없으면 생성 후 가져온다 )
* `fs.rename(기존 경로, 새 경로, 콜백)` : 파일의 이름을 바꾼다. 
* `fs.readdir(경로, 콜백)` : 폴더 안의 내용 확인
* `fs.unlink(경로, 콜백)` : 파일을 지운다. ( 없으면 에러 )
* `fs.rmdir(경로, 콜백)` : 폴더를 지운다 ( 폴더 안에 파일이 있다면 에러 )

#### 파일 복사

> 더 이상 스트림을 pipe하지 않아도 된다.

* `fs. copyFile()` : 파일을 복사한다.

## http 모듈로 웝 서버 만들기

### http모듈

* `http.createServer`를 통해 서버를 만들 수 있다.

### 쿠키와 세션

> 지금까지는 서버가 클라이언트를 구분하지 못하고 들어오는 요청에 같은 응답을 보내고있는데 클라이언트를 구분하는 방법을 배워보자.

* 서버는 요청에 대한 응답을 할 떄 `쿠키`를 같이 보낸다. 

  > 쿠키는 name=ehwoo 같은 단순한 키-값의 쌍이다.

* 서버로부터 쿠키가 오면 웹 브라우저는 쿠키를 저장해두었다가 요청할 때마다 쿠키를 동봉해서 보내고, 서버는 요청에 들어 있는 쿠키를 읽어 사용자를 파악한다.

* 브라우저는 쿠키가 있다면 자동으로 동봉해서 보내주므로 따로 처리할 필요없고

* 서버에서 브라우저로 쿠키를 보낼 때만 처리를 해주면 된다.

* `요청`과 `응답`은 `헤더`와 `본문`을 가지는데, 쿠키는 `헤더(header)`에 저장된다.

### REST API와 라우팅

* `REST API` - `REpreesentational State Transfer`
* `GET`, `POST`, `PUT`, `PATCH`, `DELETE` 
* 주소와 메서드만으로 요청 내용을 알아볼 수 있다는 장점.
* `GET` 메서드 같은 경우 브라우저에 캐싱할 수도 있어서 같은 주소의 `GET`요청을 할 때 서버에서 가져오는 것이 아니라 `캐시`에서 가져올 수도 있다. => `성능이 좋아진다.`
* `HTTP 프로토콜`을 사용하면 서버와 클라이언트가 분리되어 있어 클라이언트에 구애되지 않는 장점.

### https 와 http2

#### https

* https 모듈은 웹 서버에 SSL 암호화를 추가하여 요청이 오고 갈 때 중간에 요청을 가로채도 내용을 확인할 수 없다.
* 그렇기 떄문에 인증받은 기관에서만 받을 수 있다...

#### http2

* 노드의 `http2`모듈은 SSL 암호화와 더불어 최신 HTTP 프로토콜인 `http/2`를 사용할  수 있게 해준다. (  `http/1.1 `보다 훨씬 효율적)

### Cluster

> `cluster`모듈은 `싱글 스레드`인 노드가 CPU 코어를 모두 사용할 수 있게 해주는 모듈이다.

* 포트를 공유하는 노드 프로세스를 여러 개 두어 성능이 개선되는 장점이 있지만
* 세션을 공유하지 못하는 단점도 있다. => `Redis` 등의 서버를 도입하여 해결 가능.
* 실무에서는 `pm2`등의 모듈로 `cluster` 기능을 사용하곤 한다.





