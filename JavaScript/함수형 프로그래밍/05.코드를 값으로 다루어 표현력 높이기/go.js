const fx = require('./fx')
/*
  # 코드를 값으로 다루어 표현력 높이기
  - 04/map+filter+reduce 코드의 경우 함수 중첩으로 너무 복잡하다 그것을 간단하게 해보자
*/
/*
  ## go
  - 함수와 인자를 전달하여 즉시 값을 평가하는데 사용한다
*/
const go = (...args) => { // 하나의 값으로 축약해가는 함수이니 reduce이고, 값이 여러개 들어오니 ...args
  fx.reduce((a, f) => f(a), args) // 초기값을 안주면 알아서 첫번째값이 초기값이 될테고, 보조함수에는 a와 함수 f를 받아 f(a)가 되는 형태겠지
}

go(
  0,            // 0이
  a => a + 1,   // a로가 a + 1되고 
  a => a + 10,  // 그 결과가 또 a가 되어 a+10이 되고
  a => a + 100, // 그 결과가 또 a가 되어 a+100이 되dj
  console.log)  // 출력되는 함수 

/*
  ## pipe
  - pipe는 go과 다르게 함수를 리턴하는 함수
  - 함수들이 나열되어있는, 합성된 함수를 만드는 함수
  - 내부에서 go를 사용하는 함수라고 볼 수 있다.
*/
const pipe = (...fs) => (a) => go(a, ...fs) // 일단 함수를 리턴하는 함수, 일단 함수를 받고, 그 이후에 인자 a를 받아 go를 실행시키는 모양

const f = pipe( // 개념 먼저 설명하면, 아래의 세 함수를 연속적으로 실행하며 축약하는 하나의 함수를 만들어 리턴하는 함수를 만들고싶다. 
  a => a + 1,   
  a => a + 10,  
  a => a + 100)

console.log(f(0))


/*
  추가적으로 구현하려는 것이 예를들어 add함수가 있을 때
  시작값으로 a, b 두개를 받아야 한다면
  go 함수의 경우 0 대신 add(0, 1)을 넣으면 돼서 문제가 없지만
  pipe 함수의 경우 pipe가 받는 인자를 바꾸는게 아니라 마지막에 실행시킬 때
  console.log(add(a, b))와 같이 add의 결과값을 전달해주는 방식으로 작성해줘야해서 뭔가 아쉽다...
  pipe 함수의 첫번째 인자로 (a, b) => a + b 와 같이 두개의 인자를 받을 수도 있게 바꾸어서 
  console.log(f(0, 1))과 같이 바로 사용할 수 있게 해보자.
*/